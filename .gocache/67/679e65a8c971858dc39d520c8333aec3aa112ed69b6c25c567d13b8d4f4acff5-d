//line /Users/zambamon/Personal/scripts/network/internal/checks/bandwidth.go:1:1
package checks; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"encoding/json"
	"netcheck/internal/config"
	"netcheck/internal/eval"
	"netcheck/internal/execx"
	"netcheck/internal/model"
	"strconv"
	"strings"
	"time"
)

type SpeedtestCheck struct{}

type IperfCheck struct{}

func (SpeedtestCheck) ID() string    {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__0[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__0[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__0[2], 0) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__0[3], 1); return "bandwidth.speedtest" }
func (SpeedtestCheck) Group() string {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__1[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__1[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__1[2], 1) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__1[3], 1); return "bandwidth" }
func (IperfCheck) ID() string        {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__2[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__2[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__2[2], 2) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__2[3], 1); return "bandwidth.iperf" }
func (IperfCheck) Group() string     {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__3[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__3[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__3[2], 3) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__3[3], 1); return "bandwidth" }

func (SpeedtestCheck) Run(ctx context.Context, ex execx.Executor, cfg config.Config, timeoutSec int) model.CheckResult {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__4[0], 15) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__4[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__4[2], 4) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[3], 1);
	start := time.Now()
	if !cfg.Bandwidth.Speedtest.Enabled {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[11], 1);
		return model.CheckResult{ID: "bandwidth.speedtest", Group: "bandwidth", Status: model.StatusSkip, Error: "speedtest disabled"}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[4], 1);if _, err := ex.LookPath("speedtest-cli"); err != nil {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[12], 1);
		return model.CheckResult{ID: "bandwidth.speedtest", Group: "bandwidth", Status: model.StatusSkip, Error: "speedtest-cli not found"}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[5], 1);args := []string{"--json"}
	if cfg.Bandwidth.Speedtest.ServerID != "" {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[13], 1);
		args = append(args, "--server", cfg.Bandwidth.Speedtest.ServerID)
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[6], 1);res := runWithTimeout(ctx, timeoutSec, ex, "speedtest-cli", args...)
	if res.Err != nil && res.Stdout == "" {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[14], 1);
		return model.CheckResult{ID: "bandwidth.speedtest", Group: "bandwidth", Status: model.StatusFail, Error: res.Err.Error(), DurationMS: time.Since(start).Milliseconds()}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[7], 1);var obj map[string]any
	if err := json.Unmarshal([]byte(res.Stdout), &obj); err != nil {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[15], 1);
		return model.CheckResult{ID: "bandwidth.speedtest", Group: "bandwidth", Status: model.StatusWarn, Error: "unable to parse speedtest json", Raw: res.Stdout, DurationMS: time.Since(start).Milliseconds()}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[8], 1);dl := toMbps(obj["download"])
	ul := toMbps(obj["upload"])
	status := model.StatusPass
	if cfg.ExpectedPlan.DownloadMbps > 0 {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[16], 1);
		dlPct := dl / cfg.ExpectedPlan.DownloadMbps * 100
		status = eval.UpperIsBetter(dlPct, cfg.Thresholds.ThroughputPassPct, cfg.Thresholds.ThroughputWarnPct)
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[9], 1);if status == model.StatusPass && cfg.ExpectedPlan.UploadMbps > 0 {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[17], 1);
		ulPct := ul / cfg.ExpectedPlan.UploadMbps * 100
		status = eval.UpperIsBetter(ulPct, cfg.Thresholds.ThroughputPassPct, cfg.Thresholds.ThroughputWarnPct)
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__4[10], 1);return model.CheckResult{ID: "bandwidth.speedtest", Group: "bandwidth", Status: status, Metrics: map[string]any{"download_mbps": dl, "upload_mbps": ul}, Raw: res.Stdout, DurationMS: time.Since(start).Milliseconds()}
}

func (IperfCheck) Run(ctx context.Context, ex execx.Executor, cfg config.Config, timeoutSec int) model.CheckResult {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__5[0], 13) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__5[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__5[2], 5) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[3], 1);
	start := time.Now()
	if !cfg.Bandwidth.Iperf.Enabled {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[9], 1);
		return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Status: model.StatusSkip, Error: "iperf disabled"}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[4], 1);if cfg.Bandwidth.Iperf.Target == "" {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[10], 1);
		return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Status: model.StatusSkip, Error: "iperf target not configured"}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[5], 1);if _, err := ex.LookPath("iperf3"); err != nil {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[11], 1);
		return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Status: model.StatusSkip, Error: "iperf3 not found"}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[6], 1);args := []string{"-c", cfg.Bandwidth.Iperf.Target, "-P", strconv.Itoa(cfg.Bandwidth.Iperf.ParallelStreams), "-t", strconv.Itoa(cfg.Bandwidth.Iperf.DurationSec), "-J"}
	res := runWithTimeout(ctx, timeoutSec, ex, "iperf3", args...)
	if res.Err != nil && res.Stdout == "" {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[12], 1);
		if isIperfUnreachable(res.Err.Error(), res.Stderr) {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[14], 1);
			return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Target: cfg.Bandwidth.Iperf.Target, Status: model.StatusSkip, Error: "iperf target unreachable", DurationMS: time.Since(start).Milliseconds()}
		}
		_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[13], 1);return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Target: cfg.Bandwidth.Iperf.Target, Status: model.StatusFail, Error: res.Err.Error(), DurationMS: time.Since(start).Milliseconds()}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[7], 1);mbps := parseIperfMbps(res.Stdout)
	status := model.StatusPass
	if cfg.ExpectedPlan.DownloadMbps > 0 {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[15], 1);
		status = eval.UpperIsBetter(mbps/cfg.ExpectedPlan.DownloadMbps*100, cfg.Thresholds.ThroughputPassPct, cfg.Thresholds.ThroughputWarnPct)
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__5[8], 1);return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Target: cfg.Bandwidth.Iperf.Target, Status: status, Metrics: map[string]any{"download_mbps": mbps}, Raw: res.Stdout, DurationMS: time.Since(start).Milliseconds()}
}

func toMbps(v any) float64 {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__6[0], 3) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__6[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__6[2], 6) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__6[3], 1);
	f, ok := v.(float64)
	if !ok {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__6[5], 1);
		return 0
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__6[4], 1);return f / 1_000_000
}

func parseIperfMbps(raw string) float64 {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__7[0], 5) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__7[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__7[2], 7) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__7[3], 1);
	marker := `"bits_per_second":`
	idx := strings.LastIndex(raw, marker)
	if idx < 0 {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__7[6], 1);
		return 0
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__7[4], 1);rest := raw[idx+len(marker):]
	rest = strings.TrimSpace(rest)
	end := strings.IndexAny(rest, ",}\n")
	if end < 0 {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__7[7], 1);
		end = len(rest)
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__7[5], 1);val := strings.TrimSpace(rest[:end])
	f, _ := strconv.ParseFloat(val, 64)
	return f / 1_000_000
}

func isIperfUnreachable(errMsg, stderr string) bool {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__8[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__8[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__8[2], 8) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__8[3], 1);
	s := strings.ToLower(errMsg + " " + stderr)
	return strings.Contains(s, "unable to connect") ||
		strings.Contains(s, "no route to host") ||
		strings.Contains(s, "connection refused") ||
		strings.Contains(s, "network is unreachable") ||
		strings.Contains(s, "timed out")
}

var _ = _cover_atomic_.LoadUint32
