//line /Users/zambamon/Personal/scripts/network/internal/execx/execx.go:1:1
package execx; import _cover_atomic_ "sync/atomic"

import (
	"bytes"
	"context"
	"errors"
	"os/exec"
	"time"
)

type Result struct {
	Stdout   string
	Stderr   string
	ExitCode int
	Err      error
	Duration time.Duration
}

type Executor interface {
	Run(ctx context.Context, name string, args ...string) Result
	LookPath(file string) (string, error)
}

type RealExecutor struct{}

func (RealExecutor) Run(ctx context.Context, name string, args ...string) Result {_cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__0[0], 5) ; _cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__0[1], goCover_0eb42adf4e97_P) ; _cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__0[2], 0) ; _cover_atomic_.AddUint32(&goCover_0eb42adf4e97__0[3], 1);
	start := time.Now()
	cmd := exec.CommandContext(ctx, name, args...)
	var out, errb bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &errb
	err := cmd.Run()
	code := 0
	if err != nil {_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__0[5], 1);
		var ee *exec.ExitError
		if errors.As(err, &ee) {_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__0[6], 1);
			code = ee.ExitCode()
		} else{ _cover_atomic_.AddUint32(&goCover_0eb42adf4e97__0[7], 1);{
			code = -1
		}}
	}
	_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__0[4], 1);return Result{Stdout: out.String(), Stderr: errb.String(), ExitCode: code, Err: err, Duration: time.Since(start)}
}

func (RealExecutor) LookPath(file string) (string, error) {_cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__1[0], 1) ; _cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__1[1], goCover_0eb42adf4e97_P) ; _cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__1[2], 1) ; _cover_atomic_.AddUint32(&goCover_0eb42adf4e97__1[3], 1); return exec.LookPath(file) }

type FakeExecutor struct {
	Outputs map[string]Result
	Paths   map[string]bool
	Calls   []string
}

func (f *FakeExecutor) key(name string, args ...string) string {_cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__2[0], 3) ; _cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__2[1], goCover_0eb42adf4e97_P) ; _cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__2[2], 2) ; _cover_atomic_.AddUint32(&goCover_0eb42adf4e97__2[3], 1);
	k := name
	for _, a := range args {_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__2[5], 1);
		k += " " + a
	}
	_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__2[4], 1);return k
}

func (f *FakeExecutor) Run(_ context.Context, name string, args ...string) Result {_cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__3[0], 3) ; _cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__3[1], goCover_0eb42adf4e97_P) ; _cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__3[2], 3) ; _cover_atomic_.AddUint32(&goCover_0eb42adf4e97__3[3], 1);
	k := f.key(name, args...)
	f.Calls = append(f.Calls, k)
	if r, ok := f.Outputs[k]; ok {_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__3[5], 1);
		return r
	}
	_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__3[4], 1);return Result{ExitCode: 127, Err: errors.New("no fake output configured")}
}

func (f *FakeExecutor) LookPath(file string) (string, error) {_cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__4[0], 5) ; _cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__4[1], goCover_0eb42adf4e97_P) ; _cover_atomic_.StoreUint32(&goCover_0eb42adf4e97__4[2], 4) ; _cover_atomic_.AddUint32(&goCover_0eb42adf4e97__4[3], 1);
	if f.Paths == nil {_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__4[6], 1);
		return "", errors.New("not found")
	}
	_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__4[4], 1);if f.Paths[file] {_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__4[7], 1);
		return "/usr/bin/" + file, nil
	}
	_cover_atomic_.AddUint32(&goCover_0eb42adf4e97__4[5], 1);return "", errors.New("not found")
}

var _ = _cover_atomic_.LoadUint32
