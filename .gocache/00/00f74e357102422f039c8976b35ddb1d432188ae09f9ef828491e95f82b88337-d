//line /Users/zambamon/Personal/scripts/network/internal/config/config.go:1:1
package config

import (
	"bufio"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

type Config struct {
	Targets struct {
		Ping      []string `json:"ping"`
		DNSDomain []string `json:"dns_domains"`
		HTTPURLs  []string `json:"http_urls"`
	} `json:"targets"`
	Bandwidth struct {
		Speedtest struct {
			Enabled  bool   `json:"enabled"`
			ServerID string `json:"server_id"`
		} `json:"speedtest"`
		Iperf struct {
			Enabled         bool   `json:"enabled"`
			Target          string `json:"target"`
			ParallelStreams int    `json:"parallel_streams"`
			DurationSec     int    `json:"duration_sec"`
		} `json:"iperf"`
	} `json:"bandwidth"`
	ExpectedPlan struct {
		DownloadMbps float64 `json:"download_mbps"`
		UploadMbps   float64 `json:"upload_mbps"`
	} `json:"expected_plan"`
	Thresholds Thresholds `json:"thresholds"`
	Soak       struct {
		IntervalSec      int  `json:"interval_sec"`
		DurationSec      int  `json:"duration_sec"`
		EmitFinalSummary bool `json:"emit_final_summary"`
	} `json:"soak"`
	PerCheckTimeoutSec int `json:"per_check_timeout_sec"`
}

type Thresholds struct {
	LossPassMax              float64 `json:"loss_pass_max"`
	LossWarnMax              float64 `json:"loss_warn_max"`
	RTTP95PassMaxMs          float64 `json:"rtt_p95_pass_max_ms"`
	RTTP95WarnMaxMs          float64 `json:"rtt_p95_warn_max_ms"`
	JitterPassMaxMs          float64 `json:"jitter_pass_max_ms"`
	JitterWarnMaxMs          float64 `json:"jitter_warn_max_ms"`
	DNSPassMaxMs             float64 `json:"dns_pass_max_ms"`
	DNSWarnMaxMs             float64 `json:"dns_warn_max_ms"`
	HTTPPassMaxMs            float64 `json:"http_pass_max_ms"`
	HTTPWarnMaxMs            float64 `json:"http_warn_max_ms"`
	LoadedLatencyPassDeltaMs float64 `json:"loaded_latency_pass_delta_ms"`
	LoadedLatencyWarnDeltaMs float64 `json:"loaded_latency_warn_delta_ms"`
	ThroughputPassPct        float64 `json:"throughput_pass_pct"`
	ThroughputWarnPct        float64 `json:"throughput_warn_pct"`
}

func Defaults() Config {goCover_c7a5009a1d9c__0[0] = 1 ; goCover_c7a5009a1d9c__0[1] = goCover_c7a5009a1d9c_P ; goCover_c7a5009a1d9c__0[2] = 0 ; goCover_c7a5009a1d9c__0[3] = 1;
	var c Config
	c.Targets.Ping = []string{"1.1.1.1", "8.8.8.8"}
	c.Targets.DNSDomain = []string{"google.com"}
	c.Targets.HTTPURLs = []string{"https://example.com"}
	c.Bandwidth.Speedtest.Enabled = true
	c.Bandwidth.Iperf.Enabled = true
	c.Bandwidth.Iperf.ParallelStreams = 4
	c.Bandwidth.Iperf.DurationSec = 30
	c.Soak.IntervalSec = 5
	c.Soak.DurationSec = 0
	c.Soak.EmitFinalSummary = true
	c.PerCheckTimeoutSec = 20
	c.Thresholds = Thresholds{
		LossPassMax: 0.5, LossWarnMax: 2,
		RTTP95PassMaxMs: 40, RTTP95WarnMaxMs: 80,
		JitterPassMaxMs: 10, JitterWarnMaxMs: 25,
		DNSPassMaxMs: 50, DNSWarnMaxMs: 120,
		HTTPPassMaxMs: 800, HTTPWarnMaxMs: 2000,
		LoadedLatencyPassDeltaMs: 30, LoadedLatencyWarnDeltaMs: 80,
		ThroughputPassPct: 80, ThroughputWarnPct: 60,
	}
	return c
}

func (c Config) AsMap() map[string]any {goCover_c7a5009a1d9c__1[0] = 1 ; goCover_c7a5009a1d9c__1[1] = goCover_c7a5009a1d9c_P ; goCover_c7a5009a1d9c__1[2] = 1 ; goCover_c7a5009a1d9c__1[3] = 1;
	b, _ := json.Marshal(c)
	out := map[string]any{}
	_ = json.Unmarshal(b, &out)
	return out
}

func Load(path string) (Config, error) {goCover_c7a5009a1d9c__2[0] = 12 ; goCover_c7a5009a1d9c__2[1] = goCover_c7a5009a1d9c_P ; goCover_c7a5009a1d9c__2[2] = 2 ; goCover_c7a5009a1d9c__2[3] = 1;
	cfg := Defaults()
	if path == "" {goCover_c7a5009a1d9c__2[8] = 1;
		return cfg, nil
	}
	goCover_c7a5009a1d9c__2[4] = 1;b, err := os.ReadFile(path)
	if err != nil {goCover_c7a5009a1d9c__2[9] = 1;
		return cfg, err
	}
	goCover_c7a5009a1d9c__2[5] = 1;ext := strings.ToLower(filepath.Ext(path))
	var merged map[string]any
	switch ext {
	case ".json":goCover_c7a5009a1d9c__2[10] = 1;
		if err := json.Unmarshal(b, &merged); err != nil {goCover_c7a5009a1d9c__2[12] = 1;
			return cfg, fmt.Errorf("invalid json config: %w", err)
		}
	default:goCover_c7a5009a1d9c__2[11] = 1;
		merged, err = parseYAMLSubset(string(b))
		if err != nil {goCover_c7a5009a1d9c__2[13] = 1;
			return cfg, err
		}
	}
	goCover_c7a5009a1d9c__2[6] = 1;if err := applyMap(&cfg, merged); err != nil {goCover_c7a5009a1d9c__2[14] = 1;
		return cfg, err
	}
	goCover_c7a5009a1d9c__2[7] = 1;return cfg, validate(cfg)
}

func validate(c Config) error {goCover_c7a5009a1d9c__3[0] = 8 ; goCover_c7a5009a1d9c__3[1] = goCover_c7a5009a1d9c_P ; goCover_c7a5009a1d9c__3[2] = 3 ; goCover_c7a5009a1d9c__3[3] = 1;
	if len(c.Targets.Ping) == 0 {goCover_c7a5009a1d9c__3[7] = 1;
		return errors.New("targets.ping must not be empty")
	}
	goCover_c7a5009a1d9c__3[4] = 1;if c.Bandwidth.Iperf.Enabled && c.Bandwidth.Iperf.Target != "" {goCover_c7a5009a1d9c__3[8] = 1;
		if strings.HasPrefix(c.Bandwidth.Iperf.Target, "127.0.0.1") || strings.HasPrefix(c.Bandwidth.Iperf.Target, "localhost") {goCover_c7a5009a1d9c__3[9] = 1;
			return errors.New("bandwidth.iperf.target must be remote; localhost is not allowed")
		}
	}
	goCover_c7a5009a1d9c__3[5] = 1;if c.Thresholds.ThroughputWarnPct > c.Thresholds.ThroughputPassPct {goCover_c7a5009a1d9c__3[10] = 1;
		return errors.New("throughput_warn_pct cannot exceed throughput_pass_pct")
	}
	goCover_c7a5009a1d9c__3[6] = 1;return nil
}

func applyMap(cfg *Config, m map[string]any) error {goCover_c7a5009a1d9c__4[0] = 1 ; goCover_c7a5009a1d9c__4[1] = goCover_c7a5009a1d9c_P ; goCover_c7a5009a1d9c__4[2] = 4 ; goCover_c7a5009a1d9c__4[3] = 1;
	base, _ := json.Marshal(cfg)
	current := map[string]any{}
	_ = json.Unmarshal(base, &current)
	deepMerge(current, m)
	merged, _ := json.Marshal(current)
	return json.Unmarshal(merged, cfg)
}

func deepMerge(dst map[string]any, src map[string]any) {goCover_c7a5009a1d9c__5[0] = 6 ; goCover_c7a5009a1d9c__5[1] = goCover_c7a5009a1d9c_P ; goCover_c7a5009a1d9c__5[2] = 5 ; goCover_c7a5009a1d9c__5[3] = 1;
	for k, v := range src {goCover_c7a5009a1d9c__5[4] = 1;
		if vm, ok := v.(map[string]any); ok {goCover_c7a5009a1d9c__5[6] = 1;
			dm, ok := dst[k].(map[string]any)
			if !ok {goCover_c7a5009a1d9c__5[8] = 1;
				dm = map[string]any{}
				dst[k] = dm
			}
			goCover_c7a5009a1d9c__5[7] = 1;deepMerge(dm, vm)
			continue
		}
		goCover_c7a5009a1d9c__5[5] = 1;dst[k] = v
	}
}

// parseYAMLSubset parses a minimal YAML subset: nested maps via indentation and lists with "- " entries.
func parseYAMLSubset(src string) (map[string]any, error) {goCover_c7a5009a1d9c__6[0] = 23 ; goCover_c7a5009a1d9c__6[1] = goCover_c7a5009a1d9c_P ; goCover_c7a5009a1d9c__6[2] = 6 ; goCover_c7a5009a1d9c__6[3] = 1;
	root := map[string]any{}
	type frame struct {
		indent int
		key    string
		obj    map[string]any
	}
	stack := []frame{{indent: -1, obj: root}}
	sc := bufio.NewScanner(strings.NewReader(src))
	for sc.Scan() {goCover_c7a5009a1d9c__6[6] = 1;
		line := sc.Text()
		trim := strings.TrimSpace(line)
		if trim == "" || strings.HasPrefix(trim, "#") {goCover_c7a5009a1d9c__6[13] = 1;
			continue
		}
		goCover_c7a5009a1d9c__6[7] = 1;indent := len(line) - len(strings.TrimLeft(line, " "))
		for len(stack) > 1 && indent <= stack[len(stack)-1].indent {goCover_c7a5009a1d9c__6[14] = 1;
			stack = stack[:len(stack)-1]
		}
		goCover_c7a5009a1d9c__6[8] = 1;parent := stack[len(stack)-1].obj
		if strings.HasPrefix(trim, "- ") {goCover_c7a5009a1d9c__6[15] = 1;
			return nil, fmt.Errorf("invalid yaml: list item without key context: %s", line)
		}
		goCover_c7a5009a1d9c__6[9] = 1;parts := strings.SplitN(trim, ":", 2)
		if len(parts) != 2 {goCover_c7a5009a1d9c__6[16] = 1;
			return nil, fmt.Errorf("invalid yaml line: %s", line)
		}
		goCover_c7a5009a1d9c__6[10] = 1;key := strings.TrimSpace(parts[0])
		val := strings.TrimSpace(parts[1])
		if val == "" {goCover_c7a5009a1d9c__6[17] = 1;
			next := map[string]any{}
			parent[key] = next
			stack = append(stack, frame{indent: indent, key: key, obj: next})
			continue
		}
		goCover_c7a5009a1d9c__6[11] = 1;if strings.HasPrefix(val, "[") && strings.HasSuffix(val, "]") {goCover_c7a5009a1d9c__6[18] = 1;
			items := strings.Split(strings.TrimSuffix(strings.TrimPrefix(val, "["), "]"), ",")
			arr := make([]any, 0, len(items))
			for _, it := range items {goCover_c7a5009a1d9c__6[20] = 1;
				t := strings.TrimSpace(strings.Trim(it, `"'`))
				if t == "" {goCover_c7a5009a1d9c__6[22] = 1;
					continue
				}
				goCover_c7a5009a1d9c__6[21] = 1;arr = append(arr, t)
			}
			goCover_c7a5009a1d9c__6[19] = 1;parent[key] = arr
			continue
		}
		goCover_c7a5009a1d9c__6[12] = 1;if v, err := parseScalar(val); err == nil {goCover_c7a5009a1d9c__6[23] = 1;
			parent[key] = v
		} else{ goCover_c7a5009a1d9c__6[24] = 1;{
			parent[key] = strings.Trim(val, `"'`)
		}}
	}
	goCover_c7a5009a1d9c__6[4] = 1;if err := sc.Err(); err != nil {goCover_c7a5009a1d9c__6[25] = 1;
		return nil, err
	}
	goCover_c7a5009a1d9c__6[5] = 1;return root, nil
}

func parseScalar(v string) (any, error) {goCover_c7a5009a1d9c__7[0] = 11 ; goCover_c7a5009a1d9c__7[1] = goCover_c7a5009a1d9c_P ; goCover_c7a5009a1d9c__7[2] = 7 ; goCover_c7a5009a1d9c__7[3] = 1;
	s := strings.Trim(v, `"'`)
	if s == "true" {goCover_c7a5009a1d9c__7[9] = 1;
		return true, nil
	}
	goCover_c7a5009a1d9c__7[4] = 1;if s == "false" {goCover_c7a5009a1d9c__7[10] = 1;
		return false, nil
	}
	goCover_c7a5009a1d9c__7[5] = 1;if i, err := strconv.Atoi(s); err == nil {goCover_c7a5009a1d9c__7[11] = 1;
		return i, nil
	}
	goCover_c7a5009a1d9c__7[6] = 1;if f, err := strconv.ParseFloat(s, 64); err == nil {goCover_c7a5009a1d9c__7[12] = 1;
		return f, nil
	}
	goCover_c7a5009a1d9c__7[7] = 1;if s != "" {goCover_c7a5009a1d9c__7[13] = 1;
		return s, nil
	}
	goCover_c7a5009a1d9c__7[8] = 1;return nil, errors.New("empty scalar")
}
