//line /Users/zambamon/Personal/scripts/network/internal/checks/path.go:1:1
package checks; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"netcheck/internal/config"
	"netcheck/internal/execx"
	"netcheck/internal/model"
	"time"
)

type PathCheck struct{ Target string }

func (c PathCheck) ID() string    {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__29[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__29[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__29[2], 29) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__29[3], 1); return "path." + c.Target }
func (c PathCheck) Group() string {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__30[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__30[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__30[2], 30) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__30[3], 1); return "path" }

func (c PathCheck) Run(ctx context.Context, ex execx.Executor, cfg config.Config, timeoutSec int) model.CheckResult {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__31[0], 15) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__31[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__31[2], 31) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[3], 1);
	start := time.Now()
	if _, err := ex.LookPath("mtr"); err != nil {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[7], 1);
		if _, terr := ex.LookPath("traceroute"); terr != nil {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[11], 1);
			return model.CheckResult{ID: c.ID(), Group: c.Group(), Target: c.Target, Status: model.StatusSkip, Error: "mtr and traceroute not found"}
		}
		_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[8], 1);res := runWithTimeout(ctx, timeoutSec, ex, "traceroute", "-m", "15", c.Target)
		if res.Err != nil && res.Stdout == "" {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[12], 1);
			return model.CheckResult{ID: c.ID(), Group: c.Group(), Target: c.Target, Status: model.StatusFail, Error: res.Err.Error(), DurationMS: time.Since(start).Milliseconds()}
		}
		_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[9], 1);status := model.StatusPass
		hops, timeoutHops := parseTracerouteSummary(res.Stdout)
		if timeoutHops > 0 {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[13], 1);
			status = model.StatusWarn
		}
		_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[10], 1);return model.CheckResult{
			ID:         c.ID(),
			Group:      c.Group(),
			Target:     c.Target,
			Status:     status,
			Metrics:    map[string]any{"hop_count": hops, "timeout_hops": timeoutHops},
			Raw:        res.Stdout,
			Error:      stderrMsg(res.Stderr),
			DurationMS: time.Since(start).Milliseconds(),
		}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[4], 1);res := runWithTimeout(ctx, timeoutSec, ex, "mtr", "-rwzc", "10", c.Target)
	if res.Err != nil && res.Stdout == "" {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[14], 1);
		return model.CheckResult{ID: c.ID(), Group: c.Group(), Target: c.Target, Status: model.StatusFail, Error: res.Err.Error(), DurationMS: time.Since(start).Milliseconds()}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[5], 1);hops, nearDestLoss := parseMTRSummary(res.Stdout)
	status := model.StatusPass
	if nearDestLoss >= 2 {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[15], 1);
		status = model.StatusFail
	} else{ _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[16], 1);if nearDestLoss >= 0.5 {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[17], 1);
		status = model.StatusWarn
	}}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__31[6], 1);return model.CheckResult{
		ID:         c.ID(),
		Group:      c.Group(),
		Target:     c.Target,
		Status:     status,
		Metrics:    map[string]any{"hop_count": hops, "near_dest_loss_pct": nearDestLoss},
		Raw:        res.Stdout,
		Error:      stderrMsg(res.Stderr),
		DurationMS: time.Since(start).Milliseconds(),
	}
}

var _ = _cover_atomic_.LoadUint32
