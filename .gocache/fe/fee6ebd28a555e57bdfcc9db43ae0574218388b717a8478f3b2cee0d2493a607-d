//line /Users/zambamon/Personal/scripts/network/internal/checks/parsers.go:1:1
package checks

import (
	"math"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

var (
	packetLossRe = regexp.MustCompile(`([0-9.]+)% packet loss`)
	rttRe        = regexp.MustCompile(`min/avg/max/(?:stddev|mdev) = ([0-9.]+)/([0-9.]+)/([0-9.]+)/([0-9.]+) ms`)
	digMsRe      = regexp.MustCompile(`Query time: ([0-9]+) msec`)
	pingTimeRe   = regexp.MustCompile(`time=([0-9.]+)\s*ms`)
	mtrLineRe    = regexp.MustCompile(`^\s*\d+\.\|--\s+\S+\s+([0-9.]+)%`)
)

func parsePing(output string) (loss, avg, jitter, p95 float64) {goCover_ce70894fcd8a__22[0] = 8 ; goCover_ce70894fcd8a__22[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__22[2] = 22 ; goCover_ce70894fcd8a__22[3] = 1;
	if m := packetLossRe.FindStringSubmatch(output); len(m) == 2 {goCover_ce70894fcd8a__22[7] = 1;
		loss, _ = strconv.ParseFloat(m[1], 64)
	}
	goCover_ce70894fcd8a__22[4] = 1;if m := rttRe.FindStringSubmatch(output); len(m) == 5 {goCover_ce70894fcd8a__22[8] = 1;
		avg, _ = strconv.ParseFloat(m[2], 64)
		jitter, _ = strconv.ParseFloat(m[4], 64)
	}
	goCover_ce70894fcd8a__22[5] = 1;samples := parsePingTimeSamples(output)
	if len(samples) > 0 {goCover_ce70894fcd8a__22[9] = 1;
		p95 = percentile(samples, 95)
	} else{ goCover_ce70894fcd8a__22[10] = 1;{
		p95 = avg
	}}
	goCover_ce70894fcd8a__22[6] = 1;return
}

func parsePingTimeSamples(output string) []float64 {goCover_ce70894fcd8a__23[0] = 7 ; goCover_ce70894fcd8a__23[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__23[2] = 23 ; goCover_ce70894fcd8a__23[3] = 1;
	matches := pingTimeRe.FindAllStringSubmatch(output, -1)
	out := make([]float64, 0, len(matches))
	for _, m := range matches {goCover_ce70894fcd8a__23[5] = 1;
		if len(m) < 2 {goCover_ce70894fcd8a__23[8] = 1;
			continue
		}
		goCover_ce70894fcd8a__23[6] = 1;v, err := strconv.ParseFloat(m[1], 64)
		if err != nil {goCover_ce70894fcd8a__23[9] = 1;
			continue
		}
		goCover_ce70894fcd8a__23[7] = 1;out = append(out, v)
	}
	goCover_ce70894fcd8a__23[4] = 1;return out
}

func percentile(values []float64, p float64) float64 {goCover_ce70894fcd8a__24[0] = 11 ; goCover_ce70894fcd8a__24[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__24[2] = 24 ; goCover_ce70894fcd8a__24[3] = 1;
	if len(values) == 0 {goCover_ce70894fcd8a__24[9] = 1;
		return 0
	}
	goCover_ce70894fcd8a__24[4] = 1;cp := append([]float64(nil), values...)
	sort.Float64s(cp)
	if p <= 0 {goCover_ce70894fcd8a__24[10] = 1;
		return cp[0]
	}
	goCover_ce70894fcd8a__24[5] = 1;if p >= 100 {goCover_ce70894fcd8a__24[11] = 1;
		return cp[len(cp)-1]
	}
	goCover_ce70894fcd8a__24[6] = 1;rank := int(math.Ceil((p / 100) * float64(len(cp))))
	if rank < 1 {goCover_ce70894fcd8a__24[12] = 1;
		rank = 1
	}
	goCover_ce70894fcd8a__24[7] = 1;if rank > len(cp) {goCover_ce70894fcd8a__24[13] = 1;
		rank = len(cp)
	}
	goCover_ce70894fcd8a__24[8] = 1;return cp[rank-1]
}

func parseMTRSummary(output string) (hopCount int, nearDestLossPct float64) {goCover_ce70894fcd8a__25[0] = 9 ; goCover_ce70894fcd8a__25[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__25[2] = 25 ; goCover_ce70894fcd8a__25[3] = 1;
	lines := strings.Split(output, "\n")
	losses := make([]float64, 0)
	for _, line := range lines {goCover_ce70894fcd8a__25[6] = 1;
		line = strings.TrimSpace(line)
		if line == "" {goCover_ce70894fcd8a__25[8] = 1;
			continue
		}
		goCover_ce70894fcd8a__25[7] = 1;m := mtrLineRe.FindStringSubmatch(line)
		if len(m) == 2 {goCover_ce70894fcd8a__25[9] = 1;
			l, err := strconv.ParseFloat(m[1], 64)
			if err == nil {goCover_ce70894fcd8a__25[10] = 1;
				losses = append(losses, l)
			}
		}
	}
	goCover_ce70894fcd8a__25[4] = 1;hopCount = len(losses)
	if hopCount > 0 {goCover_ce70894fcd8a__25[11] = 1;
		nearDestLossPct = losses[hopCount-1]
	}
	goCover_ce70894fcd8a__25[5] = 1;return
}

func parseTracerouteSummary(output string) (hopCount int, timeoutHops int) {goCover_ce70894fcd8a__26[0] = 8 ; goCover_ce70894fcd8a__26[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__26[2] = 26 ; goCover_ce70894fcd8a__26[3] = 1;
	lines := strings.Split(output, "\n")
	for _, line := range lines {goCover_ce70894fcd8a__26[5] = 1;
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "traceroute ") {goCover_ce70894fcd8a__26[7] = 1;
			continue
		}
		goCover_ce70894fcd8a__26[6] = 1;fields := strings.Fields(line)
		if len(fields) > 0 {goCover_ce70894fcd8a__26[8] = 1;
			if _, err := strconv.Atoi(fields[0]); err == nil {goCover_ce70894fcd8a__26[9] = 1;
				hopCount++
				if strings.Count(line, "*") >= 3 {goCover_ce70894fcd8a__26[10] = 1;
					timeoutHops++
				}
			}
		}
	}
	goCover_ce70894fcd8a__26[4] = 1;return
}

func parseDigMS(output string) float64 {goCover_ce70894fcd8a__27[0] = 3 ; goCover_ce70894fcd8a__27[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__27[2] = 27 ; goCover_ce70894fcd8a__27[3] = 1;
	if m := digMsRe.FindStringSubmatch(output); len(m) == 2 {goCover_ce70894fcd8a__27[5] = 1;
		v, _ := strconv.ParseFloat(m[1], 64)
		return v
	}
	goCover_ce70894fcd8a__27[4] = 1;return 0
}

func parseCurlTimings(output string) map[string]float64 {goCover_ce70894fcd8a__28[0] = 7 ; goCover_ce70894fcd8a__28[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__28[2] = 28 ; goCover_ce70894fcd8a__28[3] = 1;
	parts := strings.Fields(strings.TrimSpace(output))
	res := map[string]float64{}
	for _, p := range parts {goCover_ce70894fcd8a__28[5] = 1;
		kv := strings.SplitN(p, ":", 2)
		if len(kv) != 2 {goCover_ce70894fcd8a__28[8] = 1;
			continue
		}
		goCover_ce70894fcd8a__28[6] = 1;v, err := strconv.ParseFloat(kv[1], 64)
		if err != nil {goCover_ce70894fcd8a__28[9] = 1;
			continue
		}
		goCover_ce70894fcd8a__28[7] = 1;res[kv[0]] = v * 1000
	}
	goCover_ce70894fcd8a__28[4] = 1;return res
}
