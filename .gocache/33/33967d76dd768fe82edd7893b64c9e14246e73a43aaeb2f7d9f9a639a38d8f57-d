//line /Users/zambamon/Personal/scripts/network/internal/docs/docs.go:1:1
package docs; import _cover_atomic_ "sync/atomic"

import (
	"embed"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

//go:embed man/*.md
var manFS embed.FS

var topics = map[string]string{
	"netcheck":    "man/netcheck.md",
	"run":         "man/run.md",
	"soak":        "man/soak.md",
	"compare":     "man/compare.md",
	"config":      "man/config.md",
	"exit-codes":  "man/exit-codes.md",
	"json-schema": "man/json-schema.md",
}

func Topics() []string {_cover_atomic_.StoreUint32(&goCover_31677e5b9b54__0[0], 3) ; _cover_atomic_.StoreUint32(&goCover_31677e5b9b54__0[1], goCover_31677e5b9b54_P) ; _cover_atomic_.StoreUint32(&goCover_31677e5b9b54__0[2], 0) ; _cover_atomic_.AddUint32(&goCover_31677e5b9b54__0[3], 1);
	out := make([]string, 0, len(topics))
	for k := range topics {_cover_atomic_.AddUint32(&goCover_31677e5b9b54__0[5], 1);
		out = append(out, k)
	}
	_cover_atomic_.AddUint32(&goCover_31677e5b9b54__0[4], 1);sort.Strings(out)
	return out
}

func Get(topic string) (string, error) {_cover_atomic_.StoreUint32(&goCover_31677e5b9b54__1[0], 7) ; _cover_atomic_.StoreUint32(&goCover_31677e5b9b54__1[1], goCover_31677e5b9b54_P) ; _cover_atomic_.StoreUint32(&goCover_31677e5b9b54__1[2], 1) ; _cover_atomic_.AddUint32(&goCover_31677e5b9b54__1[3], 1);
	topic = strings.TrimSpace(topic)
	if topic == "" {_cover_atomic_.AddUint32(&goCover_31677e5b9b54__1[7], 1);
		topic = "netcheck"
	}
	_cover_atomic_.AddUint32(&goCover_31677e5b9b54__1[4], 1);path, ok := topics[topic]
	if !ok {_cover_atomic_.AddUint32(&goCover_31677e5b9b54__1[8], 1);
		return "", fmt.Errorf("unknown man topic: %s", topic)
	}
	_cover_atomic_.AddUint32(&goCover_31677e5b9b54__1[5], 1);b, err := manFS.ReadFile(path)
	if err != nil {_cover_atomic_.AddUint32(&goCover_31677e5b9b54__1[9], 1);
		return "", err
	}
	_cover_atomic_.AddUint32(&goCover_31677e5b9b54__1[6], 1);return string(b), nil
}

func Export(dir string) error {_cover_atomic_.StoreUint32(&goCover_31677e5b9b54__2[0], 10) ; _cover_atomic_.StoreUint32(&goCover_31677e5b9b54__2[1], goCover_31677e5b9b54_P) ; _cover_atomic_.StoreUint32(&goCover_31677e5b9b54__2[2], 2) ; _cover_atomic_.AddUint32(&goCover_31677e5b9b54__2[3], 1);
	if err := os.MkdirAll(dir, 0o755); err != nil {_cover_atomic_.AddUint32(&goCover_31677e5b9b54__2[6], 1);
		return err
	}
	_cover_atomic_.AddUint32(&goCover_31677e5b9b54__2[4], 1);for topic, path := range topics {_cover_atomic_.AddUint32(&goCover_31677e5b9b54__2[7], 1);
		b, err := manFS.ReadFile(path)
		if err != nil {_cover_atomic_.AddUint32(&goCover_31677e5b9b54__2[10], 1);
			return err
		}
		_cover_atomic_.AddUint32(&goCover_31677e5b9b54__2[8], 1);if err := os.WriteFile(filepath.Join(dir, "netcheck-"+topic+".md"), b, 0o644); err != nil {_cover_atomic_.AddUint32(&goCover_31677e5b9b54__2[11], 1);
			return err
		}
		_cover_atomic_.AddUint32(&goCover_31677e5b9b54__2[9], 1);roff := markdownToRoff(topic, string(b))
		if err := os.WriteFile(filepath.Join(dir, "netcheck-"+topic+".1"), []byte(roff), 0o644); err != nil {_cover_atomic_.AddUint32(&goCover_31677e5b9b54__2[12], 1);
			return err
		}
	}
	_cover_atomic_.AddUint32(&goCover_31677e5b9b54__2[5], 1);return nil
}

func markdownToRoff(topic, md string) string {_cover_atomic_.StoreUint32(&goCover_31677e5b9b54__3[0], 1) ; _cover_atomic_.StoreUint32(&goCover_31677e5b9b54__3[1], goCover_31677e5b9b54_P) ; _cover_atomic_.StoreUint32(&goCover_31677e5b9b54__3[2], 3) ; _cover_atomic_.AddUint32(&goCover_31677e5b9b54__3[3], 1);
	return fmt.Sprintf(".TH NETCHECK-%s 1\n.SH NAME\nnetcheck-%s\n.SH DESCRIPTION\n%s\n", strings.ToUpper(topic), topic, strings.ReplaceAll(md, "\n", "\n.br\n"))
}

var _ = _cover_atomic_.LoadUint32
