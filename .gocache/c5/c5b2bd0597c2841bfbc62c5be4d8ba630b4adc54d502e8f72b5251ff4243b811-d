//line /Users/zambamon/Personal/scripts/network/internal/runner/runner.go:1:1
package runner

import (
	"context"
	"netcheck/internal/checks"
	"netcheck/internal/config"
	"netcheck/internal/eval"
	"netcheck/internal/execx"
	"netcheck/internal/model"
	"netcheck/internal/schema"
	"os"
	"runtime"
	"sort"
	"strings"
	"time"
)

type RunResult struct {
	Report model.Report
}

func BuildChecks(cfg config.Config) []checks.Check {goCover_19ea2b82c8a3__0[0] = 10 ; goCover_19ea2b82c8a3__0[1] = goCover_19ea2b82c8a3_P ; goCover_19ea2b82c8a3__0[2] = 0 ; goCover_19ea2b82c8a3__0[3] = 1;
	all := []checks.Check{checks.LocalCheck{}, checks.SpeedtestCheck{}, checks.IperfCheck{}}
	for _, p := range cfg.Targets.Ping {goCover_19ea2b82c8a3__0[8] = 1;
		all = append(all, checks.ReachabilityCheck{Target: p})
	}
	goCover_19ea2b82c8a3__0[4] = 1;for _, d := range cfg.Targets.DNSDomain {goCover_19ea2b82c8a3__0[9] = 1;
		all = append(all, checks.DNSCheck{Domain: d})
		for _, r := range cfg.Targets.Resolvers {goCover_19ea2b82c8a3__0[10] = 1;
			all = append(all, checks.DNSCheck{Domain: d, Resolver: r})
		}
	}
	goCover_19ea2b82c8a3__0[5] = 1;for _, u := range cfg.Targets.HTTPURLs {goCover_19ea2b82c8a3__0[11] = 1;
		all = append(all, checks.HTTPCheck{URL: u})
	}
	goCover_19ea2b82c8a3__0[6] = 1;if len(cfg.Targets.Ping) > 0 {goCover_19ea2b82c8a3__0[12] = 1;
		all = append(all, checks.PathCheck{Target: cfg.Targets.Ping[0]})
		all = append(all, checks.BufferbloatCheck{Target: cfg.Targets.Ping[0]})
	}
	goCover_19ea2b82c8a3__0[7] = 1;return all
}

func filterChecks(all []checks.Check, selectGroups, skipGroups []string) []checks.Check {goCover_19ea2b82c8a3__1[0] = 13 ; goCover_19ea2b82c8a3__1[1] = goCover_19ea2b82c8a3_P ; goCover_19ea2b82c8a3__1[2] = 1 ; goCover_19ea2b82c8a3__1[3] = 1;
	if len(selectGroups) == 0 && len(skipGroups) == 0 {goCover_19ea2b82c8a3__1[8] = 1;
		return all
	}
	goCover_19ea2b82c8a3__1[4] = 1;sel := map[string]bool{}
	skp := map[string]bool{}
	for _, g := range selectGroups {goCover_19ea2b82c8a3__1[9] = 1;
		sel[strings.TrimSpace(g)] = true
	}
	goCover_19ea2b82c8a3__1[5] = 1;for _, g := range skipGroups {goCover_19ea2b82c8a3__1[10] = 1;
		skp[strings.TrimSpace(g)] = true
	}
	goCover_19ea2b82c8a3__1[6] = 1;out := make([]checks.Check, 0, len(all))
	for _, c := range all {goCover_19ea2b82c8a3__1[11] = 1;
		if len(sel) > 0 && !sel[c.Group()] {goCover_19ea2b82c8a3__1[14] = 1;
			continue
		}
		goCover_19ea2b82c8a3__1[12] = 1;if skp[c.Group()] {goCover_19ea2b82c8a3__1[15] = 1;
			continue
		}
		goCover_19ea2b82c8a3__1[13] = 1;out = append(out, c)
	}
	goCover_19ea2b82c8a3__1[7] = 1;return out
}

func RunOnce(ctx context.Context, ex execx.Executor, cfg config.Config, opts model.RunOptions, version, commit string) (RunResult, error) {goCover_19ea2b82c8a3__2[0] = 6 ; goCover_19ea2b82c8a3__2[1] = goCover_19ea2b82c8a3_P ; goCover_19ea2b82c8a3__2[2] = 2 ; goCover_19ea2b82c8a3__2[3] = 1;
	all := filterChecks(BuildChecks(cfg), opts.Select, opts.Skip)
	res := make([]model.CheckResult, 0, len(all))
	summary := model.Summary{}
	for _, c := range all {goCover_19ea2b82c8a3__2[6] = 1;
		cr := c.Run(ctx, ex, cfg, cfg.PerCheckTimeoutSec)
		summary.Add(cr.Status)
		res = append(res, cr)
		if opts.FailFast && cr.Status == model.StatusFail {goCover_19ea2b82c8a3__2[7] = 1;
			break
		}
	}
	goCover_19ea2b82c8a3__2[4] = 1;sort.Slice(res, func(i, j int) bool {goCover_19ea2b82c8a3__2[8] = 1; return res[i].ID < res[j].ID })
	goCover_19ea2b82c8a3__2[5] = 1;host, _ := os.Hostname()
	report := model.Report{
		SchemaVersion: schema.Version,
		Timestamp:     time.Now().UTC(),
		Host:          host,
		OS:            runtime.GOOS,
		Version:       version,
		GitCommit:     commit,
		RunID:         opts.RunID,
		Labels:        opts.Labels,
		Config:        cfg.AsMap(),
		Checks:        res,
		Summary:       summary,
		Score:         eval.Score(res),
	}
	return RunResult{Report: report}, nil
}
