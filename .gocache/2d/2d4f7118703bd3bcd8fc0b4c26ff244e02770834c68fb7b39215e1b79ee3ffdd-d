//line /Users/zambamon/Personal/scripts/network/internal/checks/path.go:1:1
package checks; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"netcheck/internal/config"
	"netcheck/internal/execx"
	"netcheck/internal/model"
	"strings"
	"time"
)

type PathCheck struct{ Target string }

func (c PathCheck) ID() string    {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__23[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__23[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__23[2], 23) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__23[3], 1); return "path." + c.Target }
func (c PathCheck) Group() string {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__24[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__24[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__24[2], 24) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__24[3], 1); return "path" }

func (c PathCheck) Run(ctx context.Context, ex execx.Executor, cfg config.Config, timeoutSec int) model.CheckResult {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__25[0], 7) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__25[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__25[2], 25) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__25[3], 1);
	start := time.Now()
	if _, err := ex.LookPath("mtr"); err != nil {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__25[7], 1);
		return model.CheckResult{ID: c.ID(), Group: c.Group(), Target: c.Target, Status: model.StatusSkip, Error: "mtr not found"}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__25[4], 1);res := ex.Run(ctx, "mtr", "-rwzc", "10", c.Target)
	if res.Err != nil && res.Stdout == "" {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__25[8], 1);
		return model.CheckResult{ID: c.ID(), Group: c.Group(), Target: c.Target, Status: model.StatusFail, Error: res.Err.Error(), DurationMS: time.Since(start).Milliseconds()}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__25[5], 1);status := model.StatusPass
	if strings.Contains(res.Stdout, "100.0%") {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__25[9], 1);
		status = model.StatusFail
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__25[6], 1);return model.CheckResult{ID: c.ID(), Group: c.Group(), Target: c.Target, Status: status, Raw: res.Stdout, Error: stderrMsg(res.Stderr), DurationMS: time.Since(start).Milliseconds()}
}

var _ = _cover_atomic_.LoadUint32
