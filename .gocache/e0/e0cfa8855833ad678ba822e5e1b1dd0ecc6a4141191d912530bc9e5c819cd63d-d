//line /Users/zambamon/Personal/scripts/network/internal/eval/eval.go:1:1
package eval; import _cover_atomic_ "sync/atomic"

import "netcheck/internal/model"

type Thresholds struct {
	Pass float64
	Warn float64
}

func UpperIsBetter(value, passMin, warnMin float64) model.Status {_cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__0[0], 5) ; _cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__0[1], goCover_9862a0ffc7c5_P) ; _cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__0[2], 0) ; _cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__0[3], 1);
	if value >= passMin {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__0[6], 1);
		return model.StatusPass
	}
	_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__0[4], 1);if value >= warnMin {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__0[7], 1);
		return model.StatusWarn
	}
	_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__0[5], 1);return model.StatusFail
}

func LowerIsBetter(value, passMax, warnMax float64) model.Status {_cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__1[0], 5) ; _cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__1[1], goCover_9862a0ffc7c5_P) ; _cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__1[2], 1) ; _cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__1[3], 1);
	if value < passMax {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__1[6], 1);
		return model.StatusPass
	}
	_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__1[4], 1);if value <= warnMax {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__1[7], 1);
		return model.StatusWarn
	}
	_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__1[5], 1);return model.StatusFail
}

func Score(checks []model.CheckResult) int {_cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__2[0], 19) ; _cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__2[1], goCover_9862a0ffc7c5_P) ; _cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__2[2], 2) ; _cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[3], 1);
	if len(checks) == 0 {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[10], 1);
		return 0
	}
	_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[4], 1);weights := map[string]float64{
		"reliability": 35,
		"latency":     25,
		"dns":         10,
		"http":        10,
		"throughput":  20,
	}
	catScores := map[string][]float64{}
	for _, c := range checks {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[11], 1);
		cat := categoryForGroup(c.Group)
		if cat == "" {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[13], 1);
			continue
		}
		_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[12], 1);catScores[cat] = append(catScores[cat], statusToScore(c.Status))
	}
	_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[5], 1);var weightedTotal float64
	var totalWeight float64
	for cat, scores := range catScores {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[14], 1);
		w := weights[cat]
		if w == 0 || len(scores) == 0 {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[17], 1);
			continue
		}
		_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[15], 1);var sum float64
		for _, sc := range scores {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[18], 1);
			sum += sc
		}
		_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[16], 1);weightedTotal += (sum / float64(len(scores))) * w
		totalWeight += w
	}
	_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[6], 1);if totalWeight == 0 {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[19], 1);
		return 0
	}
	_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[7], 1);s := int((weightedTotal / totalWeight) * 100)
	if s < 0 {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[20], 1);
		return 0
	}
	_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[8], 1);if s > 100 {_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[21], 1);
		return 100
	}
	_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__2[9], 1);return s
}

func statusToScore(s model.Status) float64 {_cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__3[0], 5) ; _cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__3[1], goCover_9862a0ffc7c5_P) ; _cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__3[2], 3) ; _cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__3[3], 1);
	switch s {
	case model.StatusPass:_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__3[4], 1);
		return 1
	case model.StatusWarn:_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__3[5], 1);
		return 0.6
	case model.StatusSkip:_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__3[6], 1);
		return 0.5
	default:_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__3[7], 1);
		return 0
	}
}

func categoryForGroup(group string) string {_cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__4[0], 7) ; _cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__4[1], goCover_9862a0ffc7c5_P) ; _cover_atomic_.StoreUint32(&goCover_9862a0ffc7c5__4[2], 4) ; _cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__4[3], 1);
	switch group {
	case "local", "reachability", "path":_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__4[4], 1);
		return "reliability"
	case "bufferbloat":_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__4[5], 1);
		return "latency"
	case "dns":_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__4[6], 1);
		return "dns"
	case "http":_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__4[7], 1);
		return "http"
	case "bandwidth":_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__4[8], 1);
		return "throughput"
	default:_cover_atomic_.AddUint32(&goCover_9862a0ffc7c5__4[9], 1);
		return ""
	}
}

var _ = _cover_atomic_.LoadUint32
