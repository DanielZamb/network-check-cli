//line /Users/zambamon/Personal/scripts/network/internal/execx/execx.go:1:1
package execx

import (
	"bytes"
	"context"
	"errors"
	"os/exec"
	"time"
)

type Result struct {
	Stdout   string
	Stderr   string
	ExitCode int
	Err      error
	Duration time.Duration
}

type Executor interface {
	Run(ctx context.Context, name string, args ...string) Result
	LookPath(file string) (string, error)
}

type RealExecutor struct{}

func (RealExecutor) Run(ctx context.Context, name string, args ...string) Result {goCover_0eb42adf4e97__0[0] = 5 ; goCover_0eb42adf4e97__0[1] = goCover_0eb42adf4e97_P ; goCover_0eb42adf4e97__0[2] = 0 ; goCover_0eb42adf4e97__0[3] = 1;
	start := time.Now()
	cmd := exec.CommandContext(ctx, name, args...)
	var out, errb bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &errb
	err := cmd.Run()
	code := 0
	if err != nil {goCover_0eb42adf4e97__0[5] = 1;
		var ee *exec.ExitError
		if errors.As(err, &ee) {goCover_0eb42adf4e97__0[6] = 1;
			code = ee.ExitCode()
		} else{ goCover_0eb42adf4e97__0[7] = 1;{
			code = -1
		}}
	}
	goCover_0eb42adf4e97__0[4] = 1;return Result{Stdout: out.String(), Stderr: errb.String(), ExitCode: code, Err: err, Duration: time.Since(start)}
}

func (RealExecutor) LookPath(file string) (string, error) {goCover_0eb42adf4e97__1[0] = 1 ; goCover_0eb42adf4e97__1[1] = goCover_0eb42adf4e97_P ; goCover_0eb42adf4e97__1[2] = 1 ; goCover_0eb42adf4e97__1[3] = 1; return exec.LookPath(file) }

type FakeExecutor struct {
	Outputs map[string]Result
	Paths   map[string]bool
	Calls   []string
}

func (f *FakeExecutor) key(name string, args ...string) string {goCover_0eb42adf4e97__2[0] = 3 ; goCover_0eb42adf4e97__2[1] = goCover_0eb42adf4e97_P ; goCover_0eb42adf4e97__2[2] = 2 ; goCover_0eb42adf4e97__2[3] = 1;
	k := name
	for _, a := range args {goCover_0eb42adf4e97__2[5] = 1;
		k += " " + a
	}
	goCover_0eb42adf4e97__2[4] = 1;return k
}

func (f *FakeExecutor) Run(_ context.Context, name string, args ...string) Result {goCover_0eb42adf4e97__3[0] = 3 ; goCover_0eb42adf4e97__3[1] = goCover_0eb42adf4e97_P ; goCover_0eb42adf4e97__3[2] = 3 ; goCover_0eb42adf4e97__3[3] = 1;
	k := f.key(name, args...)
	f.Calls = append(f.Calls, k)
	if r, ok := f.Outputs[k]; ok {goCover_0eb42adf4e97__3[5] = 1;
		return r
	}
	goCover_0eb42adf4e97__3[4] = 1;return Result{ExitCode: 127, Err: errors.New("no fake output configured")}
}

func (f *FakeExecutor) LookPath(file string) (string, error) {goCover_0eb42adf4e97__4[0] = 5 ; goCover_0eb42adf4e97__4[1] = goCover_0eb42adf4e97_P ; goCover_0eb42adf4e97__4[2] = 4 ; goCover_0eb42adf4e97__4[3] = 1;
	if f.Paths == nil {goCover_0eb42adf4e97__4[6] = 1;
		return "", errors.New("not found")
	}
	goCover_0eb42adf4e97__4[4] = 1;if f.Paths[file] {goCover_0eb42adf4e97__4[7] = 1;
		return "/usr/bin/" + file, nil
	}
	goCover_0eb42adf4e97__4[5] = 1;return "", errors.New("not found")
}
