//line /Users/zambamon/Personal/scripts/network/internal/checks/bufferbloat.go:1:1
package checks; import _cover_atomic_ "sync/atomic"

import (
	"context"
	"netcheck/internal/config"
	"netcheck/internal/eval"
	"netcheck/internal/execx"
	"netcheck/internal/model"
	"time"
)

type BufferbloatCheck struct{ Target string }

func (c BufferbloatCheck) ID() string    {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__9[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__9[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__9[2], 9) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__9[3], 1); return "bufferbloat." + c.Target }
func (c BufferbloatCheck) Group() string {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__10[0], 1) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__10[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__10[2], 10) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__10[3], 1); return "bufferbloat" }

func (c BufferbloatCheck) Run(ctx context.Context, ex execx.Executor, cfg config.Config, timeoutSec int) model.CheckResult {_cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__11[0], 7) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__11[1], goCover_ce70894fcd8a_P) ; _cover_atomic_.StoreUint32(&goCover_ce70894fcd8a__11[2], 11) ; _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__11[3], 1);
	start := time.Now()
	if _, err := ex.LookPath("ping"); err != nil {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__11[6], 1);
		return model.CheckResult{ID: c.ID(), Group: c.Group(), Target: c.Target, Status: model.StatusSkip, Error: "ping not found"}
	}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__11[4], 1);idle := runWithTimeout(ctx, timeoutSec, ex, "ping", "-c", "10", c.Target)
	_, idleAvg, _, _ := parsePing(idle.Stdout)
	// Load proxy: run one bandwidth command between baseline and loaded latency samples.
	if cfg.Bandwidth.Iperf.Enabled && cfg.Bandwidth.Iperf.Target != "" {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__11[7], 1);
		_ = runWithTimeout(ctx, timeoutSec, ex, "iperf3", "-c", cfg.Bandwidth.Iperf.Target, "-P", "2", "-t", "5")
	} else{ _cover_atomic_.AddUint32(&goCover_ce70894fcd8a__11[8], 1);if cfg.Bandwidth.Speedtest.Enabled {_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__11[9], 1);
		_ = runWithTimeout(ctx, timeoutSec, ex, "speedtest-cli", "--json")
	}}
	_cover_atomic_.AddUint32(&goCover_ce70894fcd8a__11[5], 1);loaded := runWithTimeout(ctx, timeoutSec, ex, "ping", "-c", "10", c.Target)
	_, loadedAvg, _, _ := parsePing(loaded.Stdout)
	delta := loadedAvg - idleAvg
	status := eval.LowerIsBetter(delta, cfg.Thresholds.LoadedLatencyPassDeltaMs, cfg.Thresholds.LoadedLatencyWarnDeltaMs)
	return model.CheckResult{ID: c.ID(), Group: c.Group(), Target: c.Target, Status: status, Metrics: map[string]any{"idle_ms": idleAvg, "loaded_ms": loadedAvg, "delta_ms": delta}, Raw: loaded.Stdout, DurationMS: time.Since(start).Milliseconds()}
}

var _ = _cover_atomic_.LoadUint32
