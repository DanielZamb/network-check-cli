//line /Users/zambamon/Personal/scripts/network/internal/checks/bandwidth.go:1:1
package checks

import (
	"context"
	"encoding/json"
	"netcheck/internal/config"
	"netcheck/internal/eval"
	"netcheck/internal/execx"
	"netcheck/internal/model"
	"strconv"
	"strings"
	"time"
)

type SpeedtestCheck struct{}

type IperfCheck struct{}

func (SpeedtestCheck) ID() string    {goCover_ce70894fcd8a__0[0] = 1 ; goCover_ce70894fcd8a__0[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__0[2] = 0 ; goCover_ce70894fcd8a__0[3] = 1; return "bandwidth.speedtest" }
func (SpeedtestCheck) Group() string {goCover_ce70894fcd8a__1[0] = 1 ; goCover_ce70894fcd8a__1[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__1[2] = 1 ; goCover_ce70894fcd8a__1[3] = 1; return "bandwidth" }
func (IperfCheck) ID() string        {goCover_ce70894fcd8a__2[0] = 1 ; goCover_ce70894fcd8a__2[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__2[2] = 2 ; goCover_ce70894fcd8a__2[3] = 1; return "bandwidth.iperf" }
func (IperfCheck) Group() string     {goCover_ce70894fcd8a__3[0] = 1 ; goCover_ce70894fcd8a__3[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__3[2] = 3 ; goCover_ce70894fcd8a__3[3] = 1; return "bandwidth" }

func (SpeedtestCheck) Run(ctx context.Context, ex execx.Executor, cfg config.Config, timeoutSec int) model.CheckResult {goCover_ce70894fcd8a__4[0] = 15 ; goCover_ce70894fcd8a__4[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__4[2] = 4 ; goCover_ce70894fcd8a__4[3] = 1;
	start := time.Now()
	if !cfg.Bandwidth.Speedtest.Enabled {goCover_ce70894fcd8a__4[11] = 1;
		return model.CheckResult{ID: "bandwidth.speedtest", Group: "bandwidth", Status: model.StatusSkip, Error: "speedtest disabled"}
	}
	goCover_ce70894fcd8a__4[4] = 1;if _, err := ex.LookPath("speedtest-cli"); err != nil {goCover_ce70894fcd8a__4[12] = 1;
		return model.CheckResult{ID: "bandwidth.speedtest", Group: "bandwidth", Status: model.StatusSkip, Error: "speedtest-cli not found"}
	}
	goCover_ce70894fcd8a__4[5] = 1;args := []string{"--json"}
	if cfg.Bandwidth.Speedtest.ServerID != "" {goCover_ce70894fcd8a__4[13] = 1;
		args = append(args, "--server", cfg.Bandwidth.Speedtest.ServerID)
	}
	goCover_ce70894fcd8a__4[6] = 1;res := runWithTimeout(ctx, timeoutSec, ex, "speedtest-cli", args...)
	if res.Err != nil && res.Stdout == "" {goCover_ce70894fcd8a__4[14] = 1;
		return model.CheckResult{ID: "bandwidth.speedtest", Group: "bandwidth", Status: model.StatusFail, Error: res.Err.Error(), DurationMS: time.Since(start).Milliseconds()}
	}
	goCover_ce70894fcd8a__4[7] = 1;var obj map[string]any
	if err := json.Unmarshal([]byte(res.Stdout), &obj); err != nil {goCover_ce70894fcd8a__4[15] = 1;
		return model.CheckResult{ID: "bandwidth.speedtest", Group: "bandwidth", Status: model.StatusWarn, Error: "unable to parse speedtest json", Raw: res.Stdout, DurationMS: time.Since(start).Milliseconds()}
	}
	goCover_ce70894fcd8a__4[8] = 1;dl := toMbps(obj["download"])
	ul := toMbps(obj["upload"])
	status := model.StatusPass
	if cfg.ExpectedPlan.DownloadMbps > 0 {goCover_ce70894fcd8a__4[16] = 1;
		dlPct := dl / cfg.ExpectedPlan.DownloadMbps * 100
		status = eval.UpperIsBetter(dlPct, cfg.Thresholds.ThroughputPassPct, cfg.Thresholds.ThroughputWarnPct)
	}
	goCover_ce70894fcd8a__4[9] = 1;if status == model.StatusPass && cfg.ExpectedPlan.UploadMbps > 0 {goCover_ce70894fcd8a__4[17] = 1;
		ulPct := ul / cfg.ExpectedPlan.UploadMbps * 100
		status = eval.UpperIsBetter(ulPct, cfg.Thresholds.ThroughputPassPct, cfg.Thresholds.ThroughputWarnPct)
	}
	goCover_ce70894fcd8a__4[10] = 1;return model.CheckResult{ID: "bandwidth.speedtest", Group: "bandwidth", Status: status, Metrics: map[string]any{"download_mbps": dl, "upload_mbps": ul}, Raw: res.Stdout, DurationMS: time.Since(start).Milliseconds()}
}

func (IperfCheck) Run(ctx context.Context, ex execx.Executor, cfg config.Config, timeoutSec int) model.CheckResult {goCover_ce70894fcd8a__5[0] = 13 ; goCover_ce70894fcd8a__5[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__5[2] = 5 ; goCover_ce70894fcd8a__5[3] = 1;
	start := time.Now()
	if !cfg.Bandwidth.Iperf.Enabled {goCover_ce70894fcd8a__5[9] = 1;
		return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Status: model.StatusSkip, Error: "iperf disabled"}
	}
	goCover_ce70894fcd8a__5[4] = 1;if cfg.Bandwidth.Iperf.Target == "" {goCover_ce70894fcd8a__5[10] = 1;
		return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Status: model.StatusSkip, Error: "iperf target not configured"}
	}
	goCover_ce70894fcd8a__5[5] = 1;if _, err := ex.LookPath("iperf3"); err != nil {goCover_ce70894fcd8a__5[11] = 1;
		return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Status: model.StatusSkip, Error: "iperf3 not found"}
	}
	goCover_ce70894fcd8a__5[6] = 1;args := []string{"-c", cfg.Bandwidth.Iperf.Target, "-P", strconv.Itoa(cfg.Bandwidth.Iperf.ParallelStreams), "-t", strconv.Itoa(cfg.Bandwidth.Iperf.DurationSec), "-J"}
	res := runWithTimeout(ctx, timeoutSec, ex, "iperf3", args...)
	if res.Err != nil && res.Stdout == "" {goCover_ce70894fcd8a__5[12] = 1;
		if isIperfUnreachable(res.Err.Error(), res.Stderr) {goCover_ce70894fcd8a__5[14] = 1;
			return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Target: cfg.Bandwidth.Iperf.Target, Status: model.StatusSkip, Error: "iperf target unreachable", DurationMS: time.Since(start).Milliseconds()}
		}
		goCover_ce70894fcd8a__5[13] = 1;return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Target: cfg.Bandwidth.Iperf.Target, Status: model.StatusFail, Error: res.Err.Error(), DurationMS: time.Since(start).Milliseconds()}
	}
	goCover_ce70894fcd8a__5[7] = 1;mbps := parseIperfMbps(res.Stdout)
	status := model.StatusPass
	if cfg.ExpectedPlan.DownloadMbps > 0 {goCover_ce70894fcd8a__5[15] = 1;
		status = eval.UpperIsBetter(mbps/cfg.ExpectedPlan.DownloadMbps*100, cfg.Thresholds.ThroughputPassPct, cfg.Thresholds.ThroughputWarnPct)
	}
	goCover_ce70894fcd8a__5[8] = 1;return model.CheckResult{ID: "bandwidth.iperf", Group: "bandwidth", Target: cfg.Bandwidth.Iperf.Target, Status: status, Metrics: map[string]any{"download_mbps": mbps}, Raw: res.Stdout, DurationMS: time.Since(start).Milliseconds()}
}

func toMbps(v any) float64 {goCover_ce70894fcd8a__6[0] = 3 ; goCover_ce70894fcd8a__6[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__6[2] = 6 ; goCover_ce70894fcd8a__6[3] = 1;
	f, ok := v.(float64)
	if !ok {goCover_ce70894fcd8a__6[5] = 1;
		return 0
	}
	goCover_ce70894fcd8a__6[4] = 1;return f / 1_000_000
}

func parseIperfMbps(raw string) float64 {goCover_ce70894fcd8a__7[0] = 5 ; goCover_ce70894fcd8a__7[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__7[2] = 7 ; goCover_ce70894fcd8a__7[3] = 1;
	marker := `"bits_per_second":`
	idx := strings.LastIndex(raw, marker)
	if idx < 0 {goCover_ce70894fcd8a__7[6] = 1;
		return 0
	}
	goCover_ce70894fcd8a__7[4] = 1;rest := raw[idx+len(marker):]
	rest = strings.TrimSpace(rest)
	end := strings.IndexAny(rest, ",}\n")
	if end < 0 {goCover_ce70894fcd8a__7[7] = 1;
		end = len(rest)
	}
	goCover_ce70894fcd8a__7[5] = 1;val := strings.TrimSpace(rest[:end])
	f, _ := strconv.ParseFloat(val, 64)
	return f / 1_000_000
}

func isIperfUnreachable(errMsg, stderr string) bool {goCover_ce70894fcd8a__8[0] = 1 ; goCover_ce70894fcd8a__8[1] = goCover_ce70894fcd8a_P ; goCover_ce70894fcd8a__8[2] = 8 ; goCover_ce70894fcd8a__8[3] = 1;
	s := strings.ToLower(errMsg + " " + stderr)
	return strings.Contains(s, "unable to connect") ||
		strings.Contains(s, "no route to host") ||
		strings.Contains(s, "connection refused") ||
		strings.Contains(s, "network is unreachable") ||
		strings.Contains(s, "timed out")
}
